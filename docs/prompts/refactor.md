# 리팩토링 프롬프트 템플릿

> 기존 코드를 개선/리팩토링할 때 사용하는 템플릿입니다.

---

## 📋 템플릿: 코드 품질 개선

```
{파일_경로} 코드를 리팩토링해줘.

### 현재 문제
{문제점_설명}

### 개선 방향
{원하는_방향}

### 제약 조건
- 기존 기능 유지
- CLAUDE.md 컨벤션 따라줘
- 외부 인터페이스(Props, Emits, API) 변경 최소화
```

---

## 📋 템플릿: 성능 최적화

```
{파일_또는_기능} 성능을 최적화해줘.

### 현재 상황
{현재_성능_이슈}

### 측정 지표 (있다면)
{성능_수치}

### 최적화 포인트
{최적화_요청_사항}

### 제약 조건
- 기존 기능 유지
- UX 저하 없이
```

---

## 📋 템플릿: 구조 개선

```
{폴더_또는_모듈} 구조를 개선해줘.

### 현재 구조
{현재_구조}

### 문제점
{문제점}

### 원하는 구조
{목표_구조}

### 마이그레이션 계획
{단계별_계획_요청}
```

---

## 📝 예시 1: 컴포넌트 분리

```
src/views/user/UserListView.vue 코드를 리팩토링해줘.

### 현재 문제
- 한 파일에 500줄 이상의 코드
- 테이블, 필터, 모달 로직이 모두 섞여 있음
- 재사용 불가능한 구조

### 개선 방향
1. 테이블 로직 → UserTable.vue 컴포넌트로 분리
2. 필터 로직 → UserFilters.vue 컴포넌트로 분리
3. 삭제 모달 → UserDeleteModal.vue 컴포넌트로 분리
4. 비즈니스 로직 → useUserList.ts composable로 분리
5. UserListView.vue는 조합만 담당

### 제약 조건
- 기존 기능 100% 유지
- URL 쿼리 파라미터 연동 유지
- 기존 스토어 사용 유지
```

---

## 📝 예시 2: 반복 코드 제거

```
API 레이어의 반복 코드를 리팩토링해줘.

### 현재 문제
- 모든 api 파일에서 에러 처리 코드가 중복
- 로딩 상태 관리 패턴이 반복됨
- try-catch 보일러플레이트가 많음

### 파일 목록
- src/api/user.api.ts
- src/api/product.api.ts
- src/api/order.api.ts

### 개선 방향
1. 공통 에러 처리는 interceptor로 이동 (이미 있으면 확인)
2. 반복되는 타입 정의를 core/api/types.ts로 통합
3. 필요하면 래퍼 함수나 composable 생성

### 제약 조건
- 각 API의 반환 타입 유지
- 기존 호출 코드 변경 최소화
```

---

## 📝 예시 3: 성능 최적화

```
대시보드 페이지 성능을 최적화해줘.

### 현재 상황
- 초기 로딩 시 모든 위젯 데이터를 동시에 요청
- 차트 리렌더링이 빈번하게 발생
- 스크롤 시 버벅임

### 측정 지표
- 초기 로딩: ~3초
- API 요청: 6개 동시 발생
- 번들 사이즈: Chart.js가 크게 차지

### 최적화 포인트
1. API 요청 우선순위 설정 (중요 데이터 먼저)
2. 차트 컴포넌트 lazy loading
3. 위젯별 로딩 상태로 점진적 렌더링
4. 차트 데이터 변경 시 불필요한 리렌더링 방지 (shallowRef)
5. 가상화 검토 (목록 위젯)

### 제약 조건
- 기존 UI/UX 유지
- 데이터 정합성 유지
```

---

## 📝 예시 4: TypeScript 개선

```
src/stores/ 폴더의 타입 안정성을 개선해줘.

### 현재 문제
- 일부 state에 any 타입 사용
- API 응답 타입과 스토어 타입 불일치
- 타입 추론이 안 되는 곳 있음

### 파일 목록
- src/stores/user.store.ts
- src/stores/product.store.ts

### 개선 방향
1. any 타입 제거, 명시적 타입으로 교체
2. API 응답 타입 재사용
3. 제네릭 활용하여 중복 타입 감소
4. 타입 가드 추가 (필요시)

### 제약 조건
- 런타임 동작 변경 없음
- strict 모드 에러 0개 목표
```

---

## 📝 예시 5: 테스트 용이성 개선

```
src/components/user/UserForm.vue를 테스트하기 쉽게 리팩토링해줘.

### 현재 문제
- 컴포넌트 내부에서 직접 API 호출
- 전역 스토어에 강하게 의존
- 사이드 이펙트가 많아 단위 테스트 어려움

### 개선 방향
1. API 호출을 부모로 위임 (Emits 활용)
2. 스토어 의존성을 Props로 주입 가능하게
3. 순수한 프레젠테이션 컴포넌트로 변경
4. 비즈니스 로직은 composable로 분리

### 제약 조건
- 기존 기능 유지
- 부모 컴포넌트(UserCreateView, UserEditView) 수정 포함
```

---

## 📝 예시 6: 폴더 구조 개선

```
components 폴더 구조를 개선해줘.

### 현재 구조
src/components/
├── Button.vue
├── Input.vue
├── Modal.vue
├── UserCard.vue
├── UserTable.vue
├── UserForm.vue
├── ProductCard.vue
├── OrderList.vue
└── ... (30개 파일이 flat하게 존재)

### 문제점
- 공용/도메인 컴포넌트 구분 없음
- 파일 찾기 어려움
- 연관된 컴포넌트 파악 어려움

### 원하는 구조
src/
├── core/components/     # 공용 (Common 접두사)
│   ├── CommonButton.vue
│   ├── CommonInput.vue
│   └── CommonModal.vue
└── components/          # 도메인별
    ├── user/
    │   ├── UserCard.vue
    │   ├── UserTable.vue
    │   └── UserForm.vue
    ├── product/
    └── order/

### 마이그레이션 계획 요청
1. 파일 이동 순서
2. import 경로 업데이트 목록
3. 이름 변경이 필요한 파일
```

---

## 🔧 리팩토링 체크리스트

### 코드 품질
- [ ] 단일 책임 원칙 (하나의 파일/함수 = 하나의 역할)
- [ ] 중복 코드 제거
- [ ] 네이밍 명확성
- [ ] 주석 필요 없는 자명한 코드

### 타입 안정성
- [ ] any 타입 제거
- [ ] 명시적 반환 타입
- [ ] null/undefined 안전 처리
- [ ] 타입 가드 활용

### 성능
- [ ] 불필요한 리렌더링 방지
- [ ] 적절한 메모이제이션 (computed, useMemo)
- [ ] 지연 로딩 적용
- [ ] 번들 사이즈 최적화

### 테스트 용이성
- [ ] 의존성 주입 가능
- [ ] 사이드 이펙트 분리
- [ ] 순수 함수 추출
- [ ] 모킹 가능한 구조

### 유지보수성
- [ ] 일관된 패턴
- [ ] 적절한 추상화 수준
- [ ] 변경 영향 범위 최소화
- [ ] 문서화 (필요시)
